<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>越王勾践 | King Goujian Concept</title>
    <style>
        :root {
            --bronze: #c5a059;
            --dark: #050505;
            --ink: #1a1a1a;
            --paper: #f0f0f0;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--dark);
            color: var(--paper);
            font-family: "Noto Serif SC", "Songti SC", serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: none; /* Custom cursor */
        }

        /* Canvas Layer */
        #flow-field {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 0.6;
            filter: url(#ink-wash);
        }

        /* Content Layer */
        .container {
            position: relative;
            z-index: 10;
            text-align: center;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
            mix-blend-mode: difference;
        }

        h1 {
            font-size: 12vw;
            margin: 0;
            line-height: 1;
            font-weight: 900;
            letter-spacing: -0.05em;
            color: transparent;
            -webkit-text-stroke: 2px var(--bronze);
            position: relative;
            filter: url(#text-distortion);
            animation: breathe 8s infinite ease-in-out;
        }

        h1::before {
            content: attr(data-text);
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            color: var(--bronze);
            opacity: 0;
            clip-path: circle(0% at 50% 50%);
            animation: reveal 2s cubic-bezier(0.77, 0, 0.175, 1) forwards 1s;
        }

        .subtitle {
            font-size: 1.5rem;
            letter-spacing: 1em;
            margin-top: 2rem;
            text-transform: uppercase;
            color: var(--bronze);
            opacity: 0;
            transform: translateY(20px);
            animation: fadeUp 1.5s ease-out forwards 2s;
        }

        /* Custom Cursor */
        .cursor {
            position: fixed;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            border: 2px solid var(--bronze);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease;
            mix-blend-mode: difference;
        }

        .cursor-trail {
            position: fixed;
            top: 0;
            left: 0;
            width: 8px;
            height: 8px;
            background: var(--bronze);
            border-radius: 50%;
            pointer-events: none;
            z-index: 99;
            transform: translate(-50%, -50%);
            opacity: 0.6;
        }

        /* SVG Filters Hidden */
        .svg-filters {
            position: absolute;
            width: 0;
            height: 0;
            pointer-events: none;
        }

        @keyframes reveal {
            0% { clip-path: circle(0% at 50% 50%); opacity: 0; }
            100% { clip-path: circle(150% at 50% 50%); opacity: 1; }
        }

        @keyframes fadeUp {
            to { opacity: 0.8; transform: translateY(0); }
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); filter: url(#text-distortion) blur(0px); }
            50% { transform: scale(1.02); filter: url(#text-distortion) blur(1px); }
        }

        /* Noise Texture Overlay */
        .noise {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.05;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }
    </style>
</head>
<body>

    <!-- SVG Filters Definition -->
    <svg class="svg-filters">
        <defs>
            <!-- Filter for Canvas (Ink Wash Look) -->
            <filter id="ink-wash">
                <feTurbulence type="fractalNoise" baseFrequency="0.01 0.04" numOctaves="3" result="noise" />
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="20" xChannelSelector="R" yChannelSelector="G" />
                <feGaussianBlur stdDeviation="0.5" />
            </filter>

            <!-- Filter for Text (Liquid Metal / Distortion) -->
            <filter id="text-distortion">
                <feTurbulence type="turbulence" baseFrequency="0.02" numOctaves="2" result="turbulence" />
                <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="5" xChannelSelector="R" yChannelSelector="G" />
            </filter>
        </defs>
    </svg>

    <div class="noise"></div>
    <canvas id="flow-field"></canvas>

    <div class="container">
        <h1 data-text="越王勾践">越王勾践</h1>
        <div class="subtitle">The Sword of Goujian</div>
    </div>

    <div class="cursor"></div>
    <div class="cursor-trail"></div>

    <script>
        // Simplex Noise Implementation
        // Ported from standard implementation for standalone usage
        const SimplexNoise = (function() {
            function Grad(x, y, z) {
                this.x = x; this.y = y; this.z = z;
            }
            Grad.prototype.dot2 = function(x, y) { return this.x*x + this.y*y; };
            Grad.prototype.dot3 = function(x, y, z) { return this.x*x + this.y*y + this.z*z; };
            var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),
                         new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),
                         new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];
            var p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
                     190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,
                     125,136,171,168, 68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,
                     105,92,41,55,46,245,40,244,102,143,54, 65,25,63,161,1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
                     135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,
                     82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152, 2,44,154,163, 70,221,
                     153,101,155,167, 43,172,9,129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
                     251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,49,192,214, 31,181,199,106,
                     157,184, 84,204,176,115,121,50,45,127, 4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,
                     78,66,215,61,156,180];
            var perm = new Array(512);
            var gradP = new Array(512);
            for(var i=0; i<512; i++) {
                perm[i] = p[i & 255];
                gradP[i] = grad3[perm[i] % 12];
            }
            function simplex2(xin, yin) {
                var n0, n1, n2; 
                var F2 = 0.5*(Math.sqrt(3.0)-1.0);
                var s = (xin+yin)*F2; 
                var i = Math.floor(xin+s);
                var j = Math.floor(yin+s);
                var G2 = (3.0-Math.sqrt(3.0))/6.0;
                var t = (i+j)*G2;
                var X0 = i-t; 
                var Y0 = j-t;
                var x0 = xin-X0; 
                var y0 = yin-Y0;
                var i1, j1; 
                if(x0>y0) {i1=1; j1=0;} 
                else {i1=0; j1=1;} 
                var x1 = x0 - i1 + G2; 
                var y1 = y0 - j1 + G2;
                var x2 = x0 - 1.0 + 2.0 * G2; 
                var y2 = y0 - 1.0 + 2.0 * G2;
                var ii = i & 255; 
                var jj = j & 255;
                var gi0 = perm[ii+perm[jj]] % 12;
                var gi1 = perm[ii+i1+perm[jj+j1]] % 12;
                var gi2 = perm[ii+1+perm[jj+1]] % 12;
                var t0 = 0.5 - x0*x0 - y0*y0;
                if(t0<0) n0 = 0.0;
                else {t0 *= t0; n0 = t0 * t0 * grad3[gi0].dot2(x0, y0);}
                var t1 = 0.5 - x1*x1 - y1*y1;
                if(t1<0) n1 = 0.0;
                else {t1 *= t1; n1 = t1 * t1 * grad3[gi1].dot2(x1, y1);}
                var t2 = 0.5 - x2*x2 - y2*y2;
                if(t2<0) n2 = 0.0;
                else {t2 *= t2; n2 = t2 * t2 * grad3[gi2].dot2(x2, y2);}
                return 70.0 * (n0 + n1 + n2);
            }
            return { noise2D: simplex2 };
        })();

        const simplex = SimplexNoise;

        /**
         * Flow Field Animation
         * Simulates ink particles moving along a noise field
         */
        const canvas = document.getElementById('flow-field');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let particles = [];
        const particleCount = 800;
        const resolution = 15; // Smaller grid for finer detail
        let rows, cols;
        let zOff = 0; 
        let mouse = { x: -1000, y: -1000, active: false };

        class Particle {
            constructor() {
                this.reset();
                this.x = Math.random() * width;
                this.y = Math.random() * height;
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = 0;
                this.vy = 0;
                this.maxSpeed = Math.random() * 2 + 1.5;
                this.history = [];
                this.maxLength = Math.random() * 15 + 5;
                this.age = 0;
                this.lifeSpan = Math.random() * 150 + 50;
                // Bronze with varying opacity or deep ink
                this.color = Math.random() > 0.6 
                    ? `rgba(197, 160, 89, ${Math.random() * 0.5 + 0.2})` 
                    : `rgba(40, 40, 40, ${Math.random() * 0.5 + 0.2})`;
                this.width = Math.random() * 2 + 0.5;
            }

            update() {
                // Flow field calculation directly from noise
                // We scale coordinates to get smooth noise transitions
                const scale = 0.005;
                const angle = simplex.noise2D(this.x * scale, this.y * scale + zOff) * Math.PI * 2;
                
                // Base flow velocity
                this.vx += Math.cos(angle) * 0.2;
                this.vy += Math.sin(angle) * 0.2;

                // Mouse interaction (repulsion)
                const dx = this.x - mouse.x;
                const dy = this.y - mouse.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 150) {
                    const force = (150 - dist) / 150;
                    this.vx += (dx / dist) * force * 2;
                    this.vy += (dy / dist) * force * 2;
                }

                // Apply velocity and friction
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.95; // Friction
                this.vy *= 0.95;

                // Wrap around edges
                if (this.x > width) { this.x = 0; this.history = []; }
                if (this.x < 0) { this.x = width; this.history = []; }
                if (this.y > height) { this.y = 0; this.history = []; }
                if (this.y < 0) { this.y = height; this.history = []; }

                // Track history
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > this.maxLength) {
                    this.history.shift();
                }

                this.age++;
                if (this.age > this.lifeSpan) {
                    this.reset();
                }
            }

            draw(ctx) {
                if (this.history.length < 2) return;
                
                ctx.beginPath();
                ctx.moveTo(this.history[0].x, this.history[0].y);
                for (let i = 1; i < this.history.length; i++) {
                    // Quadratic bezier curve for smoother lines
                    // const xc = (this.history[i].x + this.history[i-1].x) / 2;
                    // const yc = (this.history[i].y + this.history[i-1].y) / 2;
                    // ctx.quadraticCurveTo(this.history[i-1].x, this.history[i-1].y, xc, yc);
                    ctx.lineTo(this.history[i].x, this.history[i].y);
                }
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.width;
                ctx.stroke();
            }
        }

        function init() {
            resize();
            particles = [];
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }
            animate();
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        function animate() {
            // Trail effect: clear with very low opacity
            ctx.fillStyle = 'rgba(5, 5, 5, 0.1)'; 
            ctx.fillRect(0, 0, width, height);

            zOff += 0.001; // Slowly evolve the noise field

            particles.forEach(p => {
                p.update();
                p.draw(ctx);
            });

            requestAnimationFrame(animate);
        }

        // Custom Cursor Logic
        const cursor = document.querySelector('.cursor');
        const cursorTrail = document.querySelector('.cursor-trail');
        
        window.addEventListener('resize', resize);
        
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            mouse.active = true;

            cursor.style.transform = `translate(${e.clientX}px, ${e.clientY}px) translate(-50%, -50%)`;
            
            // Smooth trail follow
            setTimeout(() => {
                cursorTrail.style.transform = `translate(${e.clientX}px, ${e.clientY}px) translate(-50%, -50%)`;
            }, 80);
        });

        window.addEventListener('mousedown', (e) => {
            // Burst effect on click
            const burstCount = 50;
            if (particles.length > 1500) {
                particles.splice(0, burstCount); // Remove oldest
            }
            
            for (let i = 0; i < burstCount; i++) {
                const p = new Particle();
                p.x = e.clientX;
                p.y = e.clientY;
                // Reset history for the new position
                p.history = [{x: p.x, y: p.y}];
                
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                
                // Override velocity
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                
                p.lifeSpan = Math.random() * 50 + 50;
                p.age = 0;
                p.color = '#c5a059'; // Gold burst
                particles.push(p);
            }
        });

        window.addEventListener('mouseout', () => {
            mouse.active = false;
            mouse.x = -1000;
            mouse.y = -1000;
        });

        init();
    </script>
</body>
</html>
